#include "record.h"

namespace Tegra {
void Record::Print(Tegra::GPU& gpu, size_t frame) {
    std::scoped_lock lock{gpu.record_mutex};
    LOG_INFO(Render_OpenGL, "Methods called for frame {}:", frame);
    std::string out;
    out.reserve(0x1000);
    for (auto& entry : gpu.METHODS_CALLED) {
        const auto methods = GetMethodNames(entry);
        const auto time = std::chrono::duration_cast<std::chrono::microseconds>(
            entry.timestamp - gpu.RECORD_TIME_ORIGIN);
        out += fmt::format("{:4} {} (0x{:04X})", time.count(), GetEngineName(entry.engine), entry.method);
        size_t i = 0;
        for (const auto& method : methods) {
            const auto arg = GetArgumentInfo(entry);
            if (i == 0) {
                out += fmt::format(" {} = {}\n", method, arg);
            } else {
                out += fmt::format("\t\t      {} = {}\n", method, arg);
            }
            ++i;
        }
    }
    LOG_INFO(Render_OpenGL, "\n{}", out);
    gpu.METHODS_CALLED.clear();
    gpu.CURRENTLY_RECORDING = false;
}

using Maxwell = Tegra::Engines::Maxwell3D;
using REG_LIST = std::array<Record::Method, 400>;

#define REG(field_name) (offsetof(Maxwell::Regs, field_name) / sizeof(u32))

[[nodiscard]] std::string Record::GetArgumentInfo(GPU::RecordEntry& entry) {
    switch (entry.engine) {
    case EngineID::FERMI_TWOD_A:
        return GetFermiArg(entry.method, entry.arg);
    case EngineID::MAXWELL_B:
        return GetMaxwellArg(entry.method, entry.arg);
    case EngineID::KEPLER_COMPUTE_B:
        return GetKeplerComputeArg(entry.method, entry.arg);
    case EngineID::KEPLER_INLINE_TO_MEMORY_B:
        return GetKeplerMemoryArg(entry.method, entry.arg);
    case EngineID::MAXWELL_DMA_COPY_A:
        return GetMaxwellDMAArg(entry.method, entry.arg);
    }
    UNREACHABLE();
    return "";
}

std::string Record::GetFermiArg(u32 method, u32 arg) {
    return "";
}

std::string Record::GetMaxwellArg(u32 method, u32 arg) {
    switch (method) {
    case REG(wait_for_idle):
        return fmt::format("{}", static_cast<bool>(arg));
    }
    return fmt::format("{:X}", arg);
}

std::string Record::GetKeplerComputeArg(u32 method, u32 arg) {
    return "";
}

std::string Record::GetKeplerMemoryArg(u32 method, u32 arg) {
    return "";
}

std::string Record::GetMaxwellDMAArg(u32 method, u32 arg) {
    return "";
}

[[nodiscard]] static constexpr REG_LIST BuildFermiMethods() {
    return {};
}

[[nodiscard]] static constexpr REG_LIST BuildMaxwellMethods() {
    return {{
        {0x0000, 0x44, 0x01, 0x0000, 0x01, 0x01, "unk_0000(OFFSET)"},
        {0x0044, 0x01, 0x01, 0x0044, 0x01, 0x01, "wait_for_idle"},
        {0x0045, 0x01, 0x01, 0x0045, 0x01, 0x04, "macros.upload_address"},
        {0x0046, 0x01, 0x01, 0x0045, 0x01, 0x04, "macros.data"},
        {0x0047, 0x01, 0x01, 0x0045, 0x01, 0x04, "macros.entry"},
        {0x0048, 0x01, 0x01, 0x0045, 0x01, 0x04, "macros.bind"},
        {0x0049, 0x01, 0x01, 0x0049, 0x01, 0x01, "shadow_ram_control"},
        {0x004A, 0x16, 0x01, 0x004A, 0x01, 0x01, "unk_004A(OFFSET)"},
        {0x0060, 0x01, 0x0C, 0x0060, 0x01, 0x01, "upload"},
        {0x006C, 0x01, 0x01, 0x006C, 0x01, 0x01, "exec_upload.linear"},
        {0x006D, 0x01, 0x01, 0x006D, 0x01, 0x01, "data_upload"},
        {0x006E, 0x16, 0x01, 0x006E, 0x01, 0x01, "unk_006E(OFFSET)"},
        {0x0084, 0x01, 0x01, 0x0084, 0x01, 0x01, "force_early_fragment_tests"},
        {0x0085, 0x2D, 0x01, 0x0085, 0x01, 0x01, "unk_0085(OFFSET)"},
        {0x00B2, 0x01, 0x01, 0x00B2, 0x01, 0x01, "sync_info.sync_point"},
        {0x00B2, 0x01, 0x01, 0x00B2, 0x01, 0x01, "sync_info.unknown"},
        {0x00B2, 0x01, 0x01, 0x00B2, 0x01, 0x01, "sync_info.increment"},
        {0x00B3, 0x15, 0x01, 0x00B3, 0x01, 0x01, "unk_00B3(OFFSET)"},
        {0x00C8, 0x01, 0x01, 0x00C8, 0x01, 0x01, "tess_mode.prim"},
        {0x00C8, 0x01, 0x01, 0x00C8, 0x01, 0x01, "tess_mode.spacing"},
        {0x00C8, 0x01, 0x01, 0x00C8, 0x01, 0x01, "tess_mode.cw"},
        {0x00C8, 0x01, 0x01, 0x00C8, 0x01, 0x01, "tess_mode.connected"},
        {0x00C9, 0x04, 0x01, 0x00C9, 0x01, 0x01, "tess_level_outer(OFFSET)"},
        {0x00CD, 0x02, 0x01, 0x00CD, 0x01, 0x01, "tess_level_inner(OFFSET)"},
        {0x00CF, 0x10, 0x01, 0x00CF, 0x01, 0x01, "unk_00CF(OFFSET)"},
        {0x00DF, 0x01, 0x01, 0x00DF, 0x01, 0x01, "rasterize_enable"},
        {0x00E0, 0x04, 0x08, 0x00E0, 0x01, 0x01, "tfb_bindings(OFFSET)"},
        {0x0100, 0xC0, 0x01, 0x0100, 0x01, 0x01, "unk_0100(OFFSET)"},
        {0x01C0, 0x04, 0x04, 0x01C0, 0x01, 0x01, "tfb_layouts(OFFSET)"},
        {0x01D0, 0x01, 0x01, 0x01D0, 0x01, 0x01, "unk_01D0(OFFSET)"},
        {0x01D1, 0x01, 0x01, 0x01D1, 0x01, 0x01, "tfb_enabled"},
        {0x01D2, 0x2E, 0x01, 0x01D2, 0x01, 0x01, "unk_01D2(OFFSET)"},
        {0x0200, 0x01, 0x01, 0x0200, 0x08, 0x10, "rt(OFFSET).address_high"},
        {0x0201, 0x01, 0x01, 0x0200, 0x08, 0x10, "rt(OFFSET).address_low"},
        {0x0202, 0x01, 0x01, 0x0200, 0x08, 0x10, "rt(OFFSET).width"},
        {0x0203, 0x01, 0x01, 0x0200, 0x08, 0x10, "rt(OFFSET).height"},
        {0x0204, 0x01, 0x01, 0x0200, 0x08, 0x10, "rt(OFFSET).format"},
        {0x0205, 0x01, 0x01, 0x0200, 0x08, 0x10, "rt(OFFSET).tile_mode"},
        {0x0206, 0x01, 0x01, 0x0200, 0x08, 0x10, "rt(OFFSET).depth"},
        {0x0206, 0x01, 0x01, 0x0200, 0x08, 0x10, "rt(OFFSET).volume"},
        {0x0207, 0x01, 0x01, 0x0200, 0x08, 0x10, "rt(OFFSET).layer_stride"},
        {0x0208, 0x01, 0x01, 0x0200, 0x08, 0x10, "rt(OFFSET).base_layer"},
        {0x0209, 0x07, 0x01, 0x0200, 0x08, 0x10, "rt(OFFSET).unk_0209"},
        {0x0280, 0x10, 0x08, 0x0280, 0x01, 0x01, "viewport_transform(OFFSET)"},
        {0x0300, 0x10, 0x04, 0x0300, 0x01, 0x01, "viewports(OFFSET)"},
        {0x0340, 0x1D, 0x01, 0x0340, 0x01, 0x01, "unk_0340(OFFSET)"},
        {0x035D, 0x01, 0x01, 0x035D, 0x01, 0x02, "vertex_buffer.first"},
        {0x035E, 0x01, 0x01, 0x035D, 0x01, 0x02, "vertex_buffer.count"},
        {0x035F, 0x01, 0x01, 0x035F, 0x01, 0x01, "depth_mode"},
        {0x0360, 0x04, 0x01, 0x0360, 0x01, 0x01, "clear_color(OFFSET)"},
        {0x0364, 0x01, 0x01, 0x0364, 0x01, 0x01, "clear_depth"},
        {0x0365, 0x03, 0x01, 0x0365, 0x01, 0x01, "unk_0365(OFFSET)"},
        {0x0368, 0x01, 0x01, 0x0368, 0x01, 0x01, "clear_stencil"},
        {0x0369, 0x02, 0x01, 0x0369, 0x01, 0x01, "unk_0369(OFFSET)"},
        {0x036B, 0x01, 0x01, 0x036B, 0x01, 0x01, "polygon_mode_front"},
        {0x036C, 0x01, 0x01, 0x036C, 0x01, 0x01, "polygon_mode_back"},
        {0x036D, 0x03, 0x01, 0x036D, 0x01, 0x01, "unk_036D(OFFSET)"},
        {0x0370, 0x01, 0x01, 0x0370, 0x01, 0x01, "polygon_offset_point_enable"},
        {0x0371, 0x01, 0x01, 0x0371, 0x01, 0x01, "polygon_offset_line_enable"},
        {0x0372, 0x01, 0x01, 0x0372, 0x01, 0x01, "polygon_offset_fill_enable"},
        {0x0373, 0x01, 0x01, 0x0373, 0x01, 0x01, "patch_vertices"},
        {0x0374, 0x04, 0x01, 0x0374, 0x01, 0x01, "unk_0374(OFFSET)"},
        {0x0378, 0x01, 0x01, 0x0378, 0x01, 0x01, "fragment_barrier"},
        {0x0379, 0x07, 0x01, 0x0379, 0x01, 0x01, "unk_0379(OFFSET)"},
        {0x0380, 0x10, 0x04, 0x0380, 0x01, 0x01, "scissor_test(OFFSET)"},
        {0x03C0, 0x15, 0x01, 0x03C0, 0x01, 0x01, "unk_03C0(OFFSET)"},
        {0x03D5, 0x01, 0x01, 0x03D5, 0x01, 0x01, "stencil_back_func_ref"},
        {0x03D6, 0x01, 0x01, 0x03D6, 0x01, 0x01, "stencil_back_mask"},
        {0x03D7, 0x01, 0x01, 0x03D7, 0x01, 0x01, "stencil_back_func_mask"},
        {0x03D8, 0x05, 0x01, 0x03D8, 0x01, 0x01, "unk_03D8(OFFSET)"},
        {0x03DD, 0x01, 0x01, 0x03DD, 0x01, 0x01, "invalidate_texture_data_cache"},
        {0x03DE, 0x01, 0x01, 0x03DE, 0x01, 0x01, "unk_03DE(OFFSET)"},
        {0x03DF, 0x01, 0x01, 0x03DF, 0x01, 0x01, "tiled_cache_barrier"},
        {0x03E0, 0x04, 0x01, 0x03E0, 0x01, 0x01, "unk_03E0(OFFSET)"},
        {0x03E4, 0x01, 0x01, 0x03E4, 0x01, 0x01, "color_mask_common"},
        {0x03E5, 0x02, 0x01, 0x03E5, 0x01, 0x01, "unk_03E5(OFFSET)"},
        {0x03E7, 0x02, 0x01, 0x03E7, 0x01, 0x01, "depth_bounds(OFFSET)"},
        {0x03E9, 0x02, 0x01, 0x03E9, 0x01, 0x01, "unk_03E9(OFFSET)"},
        {0x03EB, 0x01, 0x01, 0x03EB, 0x01, 0x01, "rt_separate_frag_data"},
        {0x03EC, 0x01, 0x01, 0x03EC, 0x01, 0x01, "unk_03EC(OFFSET)"},
        {0x03ED, 0x01, 0x01, 0x03ED, 0x01, 0x01, "multisample_raster_enable"},
        {0x03EE, 0x01, 0x01, 0x03EE, 0x01, 0x01, "multisample_raster_samples"},
        {0x03EF, 0x04, 0x01, 0x03EF, 0x01, 0x01, "multisample_sample_mask(OFFSET)"},
        {0x03F3, 0x05, 0x01, 0x03F3, 0x01, 0x01, "unk_03F3(OFFSET)"},
        {0x03F8, 0x01, 0x01, 0x03F8, 0x01, 0x05, "zeta.address_high"},
        {0x03F9, 0x01, 0x01, 0x03F8, 0x01, 0x05, "zeta.address_low"},
        {0x03FA, 0x01, 0x01, 0x03F8, 0x01, 0x05, "zeta.format"},
        {0x03FB, 0x01, 0x01, 0x03F8, 0x01, 0x05, "zeta.tile_mode"},
        {0x03FC, 0x01, 0x01, 0x03F8, 0x01, 0x05, "zeta.layer_stride"},
        {0x03FD, 0x01, 0x01, 0x03FD, 0x01, 0x02, "render_area.x"},
        {0x03FD, 0x01, 0x01, 0x03FD, 0x01, 0x02, "render_area.width"},
        {0x03FE, 0x01, 0x01, 0x03FD, 0x01, 0x02, "render_area.y"},
        {0x03FE, 0x01, 0x01, 0x03FD, 0x01, 0x02, "render_area.height"},
        {0x03FF, 0x3F, 0x01, 0x03FF, 0x01, 0x01, "unk_03FF(OFFSET)"},
        {0x043E, 0x01, 0x01, 0x043E, 0x01, 0x01, "clear_flags.stencil"},
        {0x043E, 0x01, 0x01, 0x043E, 0x01, 0x01, "clear_flags.unknown"},
        {0x043E, 0x01, 0x01, 0x043E, 0x01, 0x01, "clear_flags.scissor"},
        {0x043E, 0x01, 0x01, 0x043E, 0x01, 0x01, "clear_flags.viewport"},
        {0x043F, 0x10, 0x01, 0x043F, 0x01, 0x01, "unk_043F(OFFSET)"},
        {0x044F, 0x01, 0x01, 0x044F, 0x01, 0x01, "fill_rectangle"},
        {0x0450, 0x08, 0x01, 0x0450, 0x01, 0x01, "unk_0450(OFFSET)"},
        {0x0458, 0x20, 0x01, 0x0458, 0x01, 0x01, "vertex_attrib_format(OFFSET)"},
        {0x0478, 0x04, 0x01, 0x0478, 0x01, 0x01, "multisample_sample_locations(OFFSET)"},
        {0x047C, 0x02, 0x01, 0x047C, 0x01, 0x01, "unk_047C(OFFSET)"},
        {0x047E, 0x01, 0x01, 0x047E, 0x01, 0x01, "multisample_coverage_to_color.enable"},
        {0x047E, 0x01, 0x01, 0x047E, 0x01, 0x01, "multisample_coverage_to_color.target"},
        {0x047F, 0x08, 0x01, 0x047F, 0x01, 0x01, "unk_047F(OFFSET)"},
        {0x0487, 0x01, 0x01, 0x0487, 0x01, 0x01, "rt_control.count"},
        {0x0487, 0x01, 0x01, 0x0487, 0x01, 0x01, "rt_control.map_0"},
        {0x0487, 0x01, 0x01, 0x0487, 0x01, 0x01, "rt_control.map_1"},
        {0x0487, 0x01, 0x01, 0x0487, 0x01, 0x01, "rt_control.map_2"},
        {0x0487, 0x01, 0x01, 0x0487, 0x01, 0x01, "rt_control.map_3"},
        {0x0487, 0x01, 0x01, 0x0487, 0x01, 0x01, "rt_control.map_4"},
        {0x0487, 0x01, 0x01, 0x0487, 0x01, 0x01, "rt_control.map_5"},
        {0x0487, 0x01, 0x01, 0x0487, 0x01, 0x01, "rt_control.map_6"},
        {0x0487, 0x01, 0x01, 0x0487, 0x01, 0x01, "rt_control.map_7"},
        {0x0488, 0x02, 0x01, 0x0488, 0x01, 0x01, "unk_0488(OFFSET)"},
        {0x048A, 0x01, 0x01, 0x048A, 0x01, 0x01, "zeta_width"},
        {0x048B, 0x01, 0x01, 0x048B, 0x01, 0x01, "zeta_height"},
        {0x048C, 0x01, 0x01, 0x048C, 0x01, 0x01, "zeta_depth"},
        {0x048C, 0x01, 0x01, 0x048C, 0x01, 0x01, "zeta_volume"},
        {0x048D, 0x01, 0x01, 0x048D, 0x01, 0x01, "sampler_index"},
        {0x048E, 0x25, 0x01, 0x048E, 0x01, 0x01, "unk_048E(OFFSET)"},
        {0x04B3, 0x01, 0x01, 0x04B3, 0x01, 0x01, "depth_test_enable"},
        {0x04B4, 0x05, 0x01, 0x04B4, 0x01, 0x01, "unk_04B4(OFFSET)"},
        {0x04B9, 0x01, 0x01, 0x04B9, 0x01, 0x01, "independent_blend_enable"},
        {0x04BA, 0x01, 0x01, 0x04BA, 0x01, 0x01, "depth_write_enabled"},
        {0x04BB, 0x01, 0x01, 0x04BB, 0x01, 0x01, "alpha_test_enabled"},
        {0x04BC, 0x06, 0x01, 0x04BC, 0x01, 0x01, "unk_04BC(OFFSET)"},
        {0x04C2, 0x01, 0x01, 0x04C2, 0x01, 0x01, "d3d_cull_mode"},
        {0x04C3, 0x01, 0x01, 0x04C3, 0x01, 0x01, "depth_test_func"},
        {0x04C4, 0x01, 0x01, 0x04C4, 0x01, 0x01, "alpha_test_ref"},
        {0x04C5, 0x01, 0x01, 0x04C5, 0x01, 0x01, "alpha_test_func"},
        {0x04C6, 0x01, 0x01, 0x04C6, 0x01, 0x01, "draw_tfb_stride"},
        {0x04C7, 0x01, 0x01, 0x04C7, 0x01, 0x04, "blend_color.r"},
        {0x04C8, 0x01, 0x01, 0x04C7, 0x01, 0x04, "blend_color.g"},
        {0x04C9, 0x01, 0x01, 0x04C7, 0x01, 0x04, "blend_color.b"},
        {0x04CA, 0x01, 0x01, 0x04C7, 0x01, 0x04, "blend_color.a"},
        {0x04CB, 0x04, 0x01, 0x04CB, 0x01, 0x01, "unk_04CB(OFFSET)"},
        {0x04CF, 0x01, 0x01, 0x04CF, 0x01, 0x11, "blend.separate_alpha"},
        {0x04D0, 0x01, 0x01, 0x04CF, 0x01, 0x11, "blend.equation_rgb"},
        {0x04D1, 0x01, 0x01, 0x04CF, 0x01, 0x11, "blend.factor_source_rgb"},
        {0x04D2, 0x01, 0x01, 0x04CF, 0x01, 0x11, "blend.factor_dest_rgb"},
        {0x04D3, 0x01, 0x01, 0x04CF, 0x01, 0x11, "blend.equation_a"},
        {0x04D4, 0x01, 0x01, 0x04CF, 0x01, 0x11, "blend.factor_source_a"},
        {0x04D5, 0x01, 0x01, 0x04CF, 0x01, 0x11, "blend.unk_04D5(OFFSET)"},
        {0x04D6, 0x01, 0x01, 0x04CF, 0x01, 0x11, "blend.factor_dest_a"},
        {0x04D7, 0x01, 0x01, 0x04CF, 0x01, 0x11, "blend.enable_common"},
        {0x04D8, 0x08, 0x01, 0x04CF, 0x01, 0x11, "blend.enable(OFFSET)"},
        {0x04E0, 0x01, 0x01, 0x04E0, 0x01, 0x01, "stencil_enable"},
        {0x04E1, 0x01, 0x01, 0x04E1, 0x01, 0x01, "stencil_front_op_fail"},
        {0x04E2, 0x01, 0x01, 0x04E2, 0x01, 0x01, "stencil_front_op_zfail"},
        {0x04E3, 0x01, 0x01, 0x04E3, 0x01, 0x01, "stencil_front_op_zpass"},
        {0x04E4, 0x01, 0x01, 0x04E4, 0x01, 0x01, "stencil_front_func_func"},
        {0x04E5, 0x01, 0x01, 0x04E5, 0x01, 0x01, "stencil_front_func_ref"},
        {0x04E6, 0x01, 0x01, 0x04E6, 0x01, 0x01, "stencil_front_func_mask"},
        {0x04E7, 0x01, 0x01, 0x04E7, 0x01, 0x01, "stencil_front_mask"},
        {0x04E8, 0x02, 0x01, 0x04E8, 0x01, 0x01, "unk_04E8(OFFSET)"},
        {0x04EA, 0x01, 0x01, 0x04EA, 0x01, 0x01, "frag_color_clamp"},
        {0x04EB, 0x01, 0x01, 0x04EB, 0x01, 0x01, "screen_y_control.y_negate"},
        {0x04EB, 0x01, 0x01, 0x04EB, 0x01, 0x01, "screen_y_control.triangle_rast_flip"},
        {0x04EC, 0x01, 0x01, 0x04EC, 0x01, 0x01, "line_width_smooth"},
        {0x04ED, 0x01, 0x01, 0x04ED, 0x01, 0x01, "line_width_aliased"},
        {0x04EE, 0x1B, 0x01, 0x04EE, 0x01, 0x01, "unk_04EE(OFFSET)"},
        {0x0509, 0x01, 0x01, 0x0509, 0x01, 0x01, "invalidate_sampler_cache_no_wfi"},
        {0x050A, 0x01, 0x01, 0x050A, 0x01, 0x01, "invalidate_texture_header_cache_no_wfi"},
        {0x050B, 0x02, 0x01, 0x050B, 0x01, 0x01, "unk_050B(OFFSET)"},
        {0x050D, 0x01, 0x01, 0x050D, 0x01, 0x01, "vb_element_base"},
        {0x050E, 0x01, 0x01, 0x050E, 0x01, 0x01, "vb_base_instance"},
        {0x050F, 0x35, 0x01, 0x050F, 0x01, 0x01, "unk_050F(OFFSET)"},
        {0x0544, 0x01, 0x01, 0x0544, 0x01, 0x01, "clip_distance_enabled"},
        {0x0545, 0x01, 0x01, 0x0545, 0x01, 0x01, "samplecnt_enable"},
        {0x0546, 0x01, 0x01, 0x0546, 0x01, 0x01, "point_size"},
        {0x0547, 0x01, 0x01, 0x0547, 0x01, 0x01, "unk_0547(OFFSET)"},
        {0x0548, 0x01, 0x01, 0x0548, 0x01, 0x01, "point_sprite_enable"},
        {0x0549, 0x03, 0x01, 0x0549, 0x01, 0x01, "unk_0549(OFFSET)"},
        {0x054C, 0x01, 0x01, 0x054C, 0x01, 0x01, "counter_reset"},
        {0x054D, 0x01, 0x01, 0x054D, 0x01, 0x01, "multisample_enable"},
        {0x054E, 0x01, 0x01, 0x054E, 0x01, 0x01, "zeta_enable"},
        {0x054F, 0x01, 0x01, 0x054F, 0x01, 0x01, "multisample_control.alpha_to_coverage"},
        {0x054F, 0x01, 0x01, 0x054F, 0x01, 0x01, "multisample_control.alpha_to_one"},
        {0x0550, 0x04, 0x01, 0x0550, 0x01, 0x01, "unk_0550(OFFSET)"},
        {0x0554, 0x01, 0x01, 0x0554, 0x01, 0x03, "condition.address_high"},
        {0x0555, 0x01, 0x01, 0x0554, 0x01, 0x03, "condition.address_low"},
        {0x0556, 0x01, 0x01, 0x0554, 0x01, 0x03, "condition.mode"},
        {0x0557, 0x01, 0x01, 0x0557, 0x01, 0x03, "tsc.address_high"},
        {0x0558, 0x01, 0x01, 0x0557, 0x01, 0x03, "tsc.address_low"},
        {0x0559, 0x01, 0x01, 0x0557, 0x01, 0x03, "tsc.limit"},
        {0x055A, 0x01, 0x01, 0x055A, 0x01, 0x01, "unk_055A(OFFSET)"},
        {0x055B, 0x01, 0x01, 0x055B, 0x01, 0x01, "polygon_offset_factor"},
        {0x055C, 0x01, 0x01, 0x055C, 0x01, 0x01, "line_smooth_enable"},
        {0x055D, 0x01, 0x01, 0x055D, 0x01, 0x03, "tic.address_high"},
        {0x055E, 0x01, 0x01, 0x055D, 0x01, 0x03, "tic.address_low"},
        {0x055F, 0x01, 0x01, 0x055D, 0x01, 0x03, "tic.limit"},
        {0x0560, 0x05, 0x01, 0x0560, 0x01, 0x01, "unk_0560(OFFSET)"},
        {0x0565, 0x01, 0x01, 0x0565, 0x01, 0x01, "stencil_two_side_enable"},
        {0x0566, 0x01, 0x01, 0x0566, 0x01, 0x01, "stencil_back_op_fail"},
        {0x0567, 0x01, 0x01, 0x0567, 0x01, 0x01, "stencil_back_op_zfail"},
        {0x0568, 0x01, 0x01, 0x0568, 0x01, 0x01, "stencil_back_op_zpass"},
        {0x0569, 0x01, 0x01, 0x0569, 0x01, 0x01, "stencil_back_func_func"},
        {0x056A, 0x04, 0x01, 0x056A, 0x01, 0x01, "unk_056A(OFFSET)"},
        {0x056E, 0x01, 0x01, 0x056E, 0x01, 0x01, "framebuffer_srgb"},
        {0x056F, 0x01, 0x01, 0x056F, 0x01, 0x01, "polygon_offset_units"},
        {0x0570, 0x04, 0x01, 0x0570, 0x01, 0x01, "unk_0570(OFFSET)"},
        {0x0574, 0x01, 0x01, 0x0574, 0x01, 0x01, "multisample_mode"},
        {0x0575, 0x0C, 0x01, 0x0575, 0x01, 0x01, "unk_0575(OFFSET)"},
        {0x0581, 0x01, 0x01, 0x0581, 0x01, 0x01, "point_coord_replace.coord_origin"},
        {0x0581, 0x01, 0x01, 0x0581, 0x01, 0x01, "point_coord_replace.enable"},
        {0x0582, 0x01, 0x01, 0x0582, 0x01, 0x02, "code_address.code_address_high"},
        {0x0583, 0x01, 0x01, 0x0582, 0x01, 0x02, "code_address.code_address_low"},
        {0x0584, 0x01, 0x01, 0x0584, 0x01, 0x01, "unk_0584(OFFSET)"},
        {0x0585, 0x01, 0x01, 0x0585, 0x01, 0x02, "draw.vertex_end_gl"},
        {0x0586, 0x01, 0x01, 0x0585, 0x01, 0x02, "draw.vertex_begin_gl"},
        {0x0586, 0x01, 0x01, 0x0585, 0x01, 0x02, "draw.topology"},
        {0x0586, 0x01, 0x01, 0x0585, 0x01, 0x02, "draw.instance_next"},
        {0x0586, 0x01, 0x01, 0x0585, 0x01, 0x02, "draw.instance_cont"},
        {0x0587, 0x0A, 0x01, 0x0587, 0x01, 0x01, "unk_0587(OFFSET)"},
        {0x0591, 0x01, 0x01, 0x0591, 0x01, 0x02, "primitive_restart.enabled"},
        {0x0592, 0x01, 0x01, 0x0591, 0x01, 0x02, "primitive_restart.index"},
        {0x0593, 0x5F, 0x01, 0x0593, 0x01, 0x01, "unk_0593(OFFSET)"},
        {0x05F2, 0x01, 0x01, 0x05F2, 0x01, 0x07, "index_array.start_addr_high"},
        {0x05F3, 0x01, 0x01, 0x05F2, 0x01, 0x07, "index_array.start_addr_low"},
        {0x05F4, 0x01, 0x01, 0x05F2, 0x01, 0x07, "index_array.end_addr_high"},
        {0x05F5, 0x01, 0x01, 0x05F2, 0x01, 0x07, "index_array.end_addr_low"},
        {0x05F6, 0x01, 0x01, 0x05F2, 0x01, 0x07, "index_array.format"},
        {0x05F7, 0x01, 0x01, 0x05F2, 0x01, 0x07, "index_array.first"},
        {0x05F8, 0x01, 0x01, 0x05F2, 0x01, 0x07, "index_array.count"},
        {0x05F9, 0x26, 0x01, 0x05F9, 0x01, 0x01, "unk_05F9(OFFSET)"},
        {0x061F, 0x01, 0x01, 0x061F, 0x01, 0x01, "polygon_offset_clamp"},
        {0x0620, 0x20, 0x01, 0x0620, 0x01, 0x20, "instanced_arrays.is_instanced(OFFSET)"},
        {0x0640, 0x04, 0x01, 0x0640, 0x01, 0x01, "unk_0640(OFFSET)"},
        {0x0644, 0x01, 0x01, 0x0644, 0x01, 0x01, "vp_point_size.enable"},
        {0x0644, 0x01, 0x01, 0x0644, 0x01, 0x01, "vp_point_size.unk4"},
        {0x0645, 0x01, 0x01, 0x0645, 0x01, 0x01, "unk_0645(OFFSET)"},
        {0x0646, 0x01, 0x01, 0x0646, 0x01, 0x01, "cull_test_enabled"},
        {0x0647, 0x01, 0x01, 0x0647, 0x01, 0x01, "front_face"},
        {0x0648, 0x01, 0x01, 0x0648, 0x01, 0x01, "cull_face"},
        {0x0649, 0x01, 0x01, 0x0649, 0x01, 0x01, "pixel_center_integer"},
        {0x064A, 0x01, 0x01, 0x064A, 0x01, 0x01, "unk_064A(OFFSET)"},
        {0x064B, 0x01, 0x01, 0x064B, 0x01, 0x01, "viewport_transform_enabled"},
        {0x064C, 0x03, 0x01, 0x064C, 0x01, 0x01, "unk_064C(OFFSET)"},
        {0x064F, 0x01, 0x01, 0x064F, 0x01, 0x01, "view_volume_clip_control.depth_range_0_1"},
        {0x064F, 0x01, 0x01, 0x064F, 0x01, 0x01, "view_volume_clip_control.depth_clamp_near"},
        {0x064F, 0x01, 0x01, 0x064F, 0x01, 0x01, "view_volume_clip_control.depth_clamp_far"},
        {0x064F, 0x01, 0x01, 0x064F, 0x01, 0x01, "view_volume_clip_control.depth_clamp_disabled"},
        {0x0650, 0x1F, 0x01, 0x0650, 0x01, 0x01, "unk_0650(OFFSET)"},
        {0x066F, 0x01, 0x01, 0x066F, 0x01, 0x01, "depth_bounds_enable"},
        {0x0670, 0x01, 0x01, 0x0670, 0x01, 0x01, "unk_0670(OFFSET)"},
        {0x0671, 0x01, 0x01, 0x0671, 0x01, 0x02, "logic_op.enable"},
        {0x0672, 0x01, 0x01, 0x0671, 0x01, 0x02, "logic_op.operation"},
        {0x0673, 0x01, 0x01, 0x0673, 0x01, 0x01, "unk_0673(OFFSET)"},
        {0x0674, 0x01, 0x01, 0x0674, 0x01, 0x01, "clear_buffers.raw"},
        {0x0674, 0x01, 0x01, 0x0674, 0x01, 0x01, "clear_buffers.Z"},
        {0x0674, 0x01, 0x01, 0x0674, 0x01, 0x01, "clear_buffers.S"},
        {0x0674, 0x01, 0x01, 0x0674, 0x01, 0x01, "clear_buffers.R"},
        {0x0674, 0x01, 0x01, 0x0674, 0x01, 0x01, "clear_buffers.G"},
        {0x0674, 0x01, 0x01, 0x0674, 0x01, 0x01, "clear_buffers.B"},
        {0x0674, 0x01, 0x01, 0x0674, 0x01, 0x01, "clear_buffers.A"},
        {0x0674, 0x01, 0x01, 0x0674, 0x01, 0x01, "clear_buffers.RT"},
        {0x0674, 0x01, 0x01, 0x0674, 0x01, 0x01, "clear_buffers.layer"},
        {0x0675, 0x0B, 0x01, 0x0675, 0x01, 0x01, "unk_0675(OFFSET)"},
        {0x0680, 0x08, 0x01, 0x0680, 0x01, 0x01, "color_mask(OFFSET)"},
        {0x0688, 0x38, 0x01, 0x0688, 0x01, 0x01, "unk_0688(OFFSET)"},
        {0x06C0, 0x01, 0x01, 0x06C0, 0x01, 0x04, "query.query_address_high"},
        {0x06C1, 0x01, 0x01, 0x06C0, 0x01, 0x04, "query.query_address_low"},
        {0x06C2, 0x01, 0x01, 0x06C0, 0x01, 0x04, "query.query_sequence"},
        {0x06C3, 0x01, 0x01, 0x06C0, 0x01, 0x04, "query.query_get.raw"},
        {0x06C3, 0x01, 0x01, 0x06C0, 0x01, 0x04, "query.query_get.operation"},
        {0x06C3, 0x01, 0x01, 0x06C0, 0x01, 0x04, "query.query_get.fence"},
        {0x06C3, 0x01, 0x01, 0x06C0, 0x01, 0x04, "query.query_get.unit"},
        {0x06C3, 0x01, 0x01, 0x06C0, 0x01, 0x04, "query.query_get.sync_cond"},
        {0x06C3, 0x01, 0x01, 0x06C0, 0x01, 0x04, "query.query_get.select"},
        {0x06C3, 0x01, 0x01, 0x06C0, 0x01, 0x04, "query.query_get.short_query"},
        {0x06C4, 0x3C, 0x01, 0x06C4, 0x01, 0x01, "unk_06C4(OFFSET)"},
        {0x0700, 0x01, 0x01, 0x0700, 0x20, 0x04, "vertex_array(OFFSET).stride"},
        {0x0700, 0x01, 0x01, 0x0700, 0x20, 0x04, "vertex_array(OFFSET).enable"},
        {0x0701, 0x01, 0x01, 0x0700, 0x20, 0x04, "vertex_array(OFFSET).start_high"},
        {0x0702, 0x01, 0x01, 0x0700, 0x20, 0x04, "vertex_array(OFFSET).start_low"},
        {0x0703, 0x01, 0x01, 0x0700, 0x20, 0x04, "vertex_array(OFFSET).divisor"},
        {0x0780, 0x08, 0x08, 0x0780, 0x01, 0x01, "independent_blend(OFFSET)"},
        {0x07C0, 0x01, 0x01, 0x07C0, 0x20, 0x02, "vertex_array_limit(OFFSET).limit_high"},
        {0x07C1, 0x01, 0x01, 0x07C0, 0x20, 0x02, "vertex_array_limit(OFFSET).limit_low"},
        {0x0800, 0x01, 0x01, 0x0800, 0x06, 0x10, "shader_config(OFFSET).enable"},
        {0x0800, 0x01, 0x01, 0x0800, 0x06, 0x10, "shader_config(OFFSET).program"},
        {0x0801, 0x01, 0x01, 0x0800, 0x06, 0x10, "shader_config(OFFSET).offset"},
        {0x0802, 0x0E, 0x01, 0x0800, 0x06, 0x10, "shader_config(OFFSET).unk_0802(OFFSET)"},
        {0x0860, 0x60, 0x01, 0x0860, 0x01, 0x01, "unk_0860(OFFSET)"},
        {0x08C0, 0x20, 0x01, 0x08C0, 0x01, 0x01, "firmware(OFFSET)"},
        {0x08E0, 0x01, 0x01, 0x08E0, 0x01, 0x14, "const_buffer.cb_size"},
        {0x08E1, 0x01, 0x01, 0x08E0, 0x01, 0x14, "const_buffer.cb_address_high"},
        {0x08E2, 0x01, 0x01, 0x08E0, 0x01, 0x14, "const_buffer.cb_address_low"},
        {0x08E3, 0x01, 0x01, 0x08E0, 0x01, 0x14, "const_buffer.cb_pos"},
        {0x08E4, 0x10, 0x01, 0x08E0, 0x01, 0x14, "const_buffer.cb_data(OFFSET)"},
        {0x08F4, 0x10, 0x01, 0x08F4, 0x01, 0x01, "unk_08F4(OFFSET)"},
        {0x0904, 0x01, 0x01, 0x0904, 0x05, 0x08, "cb_bind(OFFSET).raw_config"},
        {0x0904, 0x01, 0x01, 0x0904, 0x05, 0x08, "cb_bind(OFFSET).valid"},
        {0x0904, 0x01, 0x01, 0x0904, 0x05, 0x08, "cb_bind(OFFSET).index"},
        {0x0905, 0x07, 0x01, 0x0904, 0x05, 0x08, "cb_bind(OFFSET).unk_0905(OFFSET)"},
        {0x092C, 0x56, 0x01, 0x092C, 0x01, 0x01, "unk_092C(OFFSET)"},
        {0x0982, 0x01, 0x01, 0x0982, 0x01, 0x01, "tex_cb_index"},
        {0x0983, 0x7D, 0x01, 0x0983, 0x01, 0x01, "unk_0983(OFFSET)"},
        {0x0A00, 0x04, 0x20, 0x0A00, 0x01, 0x01, "tfb_varying_locs(OFFSET)"},
        {0x0A80, 0x298, 0x01, 0x0A80, 0x01, 0x01, "unk_0A80(OFFSET)"},
        {0x0D18, 0x01, 0x01, 0x0D18, 0x01, 0x01, "ssbo_info.buffer_address"},
        {0x0D19, 0x11, 0x01, 0x0D19, 0x01, 0x01, "unk_0D19(OFFSET)"},
        {0x0D2A, 0x05, 0x01, 0x0D2A, 0x01, 0x0A, "tex_info_buffers.address(OFFSET)"},
        {0x0D2F, 0x05, 0x01, 0x0D2A, 0x01, 0x0A, "tex_info_buffers.size(OFFSET)"},
        {0x0D34, 0xCC, 0x01, 0x0D34, 0x01, 0x01, "unk_0D34(OFFSET)"},
    }};
}

[[nodiscard]] static constexpr REG_LIST BuildKeplerComputeMethods() {
    return {};
}

[[nodiscard]] static constexpr REG_LIST BuildKeplerMemoryMethods() {
    return {};
}

[[nodiscard]] static constexpr REG_LIST BuildMaxwellDMAMethods() {
    return {};
}

static constexpr REG_LIST METHODS_FERMI{BuildFermiMethods()};
static constexpr REG_LIST METHODS_MAXWELL{BuildMaxwellMethods()};
static constexpr REG_LIST METHODS_KEPLERCOMPUTE{BuildKeplerComputeMethods()};
static constexpr REG_LIST METHODS_KEPLERMEMORY{BuildKeplerMemoryMethods()};
static constexpr REG_LIST METHODS_MAXWELLDMA{BuildMaxwellDMAMethods()};

#pragma optimize("", off)
std::vector<std::string> Record::GetMethodNames(GPU::RecordEntry& entry) {
    std::vector<std::string> methods_found;
    const REG_LIST* methods = nullptr;

    switch (entry.engine) {
    case EngineID::FERMI_TWOD_A:
        methods = &METHODS_FERMI;
        break;
    case EngineID::MAXWELL_B:
        methods = &METHODS_MAXWELL;
        break;
    case EngineID::KEPLER_COMPUTE_B:
        methods = &METHODS_KEPLERCOMPUTE;
        break;
    case EngineID::KEPLER_INLINE_TO_MEMORY_B:
        methods = &METHODS_KEPLERMEMORY;
        break;
    case EngineID::MAXWELL_DMA_COPY_A:
        methods = &METHODS_MAXWELLDMA;
        break;
    default:
        UNREACHABLE();
        break;
    }

    if (!methods) {
        methods_found.emplace_back("Unknown");
        return methods_found;
    }

    if (entry.method >= 0xE00) {
        methods_found.emplace_back(fmt::format("Macro[{}]", (entry.method - 0xE00) / 2));
        return methods_found;
    }

    for (const auto& method : *methods) {
        size_t this_struct_size =
            method.struct_count > 1
                ? method.struct_base + (method.struct_count * method.struct_size)
                : method.offset + (method.elem_count * method.elem_size);
        if (method.offset <= entry.method && entry.method < this_struct_size) {
            size_t base_offset =
                method.struct_base + ((entry.method - method.struct_base) % method.struct_size);
            auto start_it =
                std::find_if(methods->cbegin(), methods->cend(),
                             [&method](const auto& a) { return a.offset == method.struct_base; });
            // Find the method which contains what we're looking for
            while (start_it->offset < base_offset) {
                start_it++;
            }

            if (start_it->offset > base_offset) {
                start_it--;
            }

            const size_t struct_idx = (entry.method - method.struct_base) / method.struct_size;
            size_t element_idx = (base_offset - start_it->offset) / method.elem_size;
            if (base_offset == start_it->offset) {
                element_idx = struct_idx;
            }
            const u32 found_offset = start_it->offset;

            while (start_it < methods->cend() && start_it->offset == found_offset) {
                std::string name{start_it->name};

                if (start_it->struct_count > 1) {
                    size_t it = name.find("(OFFSET)");
                    if (it != std::string::npos) {
                        const std::string pref = name.substr(0, it);
                        const std::string suff = name.substr(it + 8);
                        name = pref + fmt::format("[{}]", struct_idx) + suff;
                    }
                }

                if (start_it->elem_count > 1) {
                    size_t it = name.find("(OFFSET)");
                    if (it != std::string::npos) {
                        const std::string pref = name.substr(0, it);
                        const std::string suff = name.substr(it + 8);
                        name = pref + fmt::format("[{}]", element_idx) + suff;
                    }
                }

                methods_found.emplace_back(name);
                ++start_it;
            }
            return methods_found;
        }
    }

    methods_found.emplace_back("Unknown");
    return methods_found;
}
#pragma optimize("", on)

} // namespace Tegra
